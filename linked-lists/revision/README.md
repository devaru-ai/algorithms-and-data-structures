## 1. The "Runner" Technique (Fast & Slow Pointers)

Prove mathematically where the pointers meet in a cycle
It turns $O(N)$ space solutions into $O(1)$ space.

1. Middle of the Linked List 
2. Linked List Cycle (detection)
3. Linked List Cycle II (finding the entrance nodeâ€”this requires math)
4. Remove Nth Node From End of List

## 2. In-Place Reversal

Reverse a specific sub-section of a list (from index $M$ to $N$) in one pass

1. Reverse Linked List (Iterative & Recursive)
2. Palindrome Linked List 
3. Reverse Nodes in k-Group

## 3. The "Dummy Node" Strategy

Reach for a dummy node when the head of the list might change
1. Remove Linked List Elements
2. Partition List
3. Merge Two Sorted Lists

## 4. Two-List Manipulation (Merging & Intersecting)

Handle asynchronous list lengths and synchronization.
1. Intersection of Two Linked Lists 
2. Add Two Numbers 
3. Merge k Sorted Lists (Combines Linked Lists with Min-Heaps/Priority Queues)
   
## 5. Doubly Linked Lists & Design

How Linked Lists are used in real-world OS kernels and caches.
1. Flatten a Multilevel Doubly Linked List
2. LRU Cache 
3. LFU Cache
